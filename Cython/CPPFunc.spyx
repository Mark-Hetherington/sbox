r"""
    The interface for calling "cpp" functions

AUTHORS:

- Oleksandr Kazymyrov (2013-04-26): initial version

- Anna Maria Eilertsen, Oleksandr Kazymyrov (2013-08-14): updated description
"""

#*****************************************************************************
#       Copyright (C) 2013 Oleksandr Kazymyrov <oleksandr.kazymyrov@ii.uib.no>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************    

#clang c++
#cargs -Wall -Werror
#cinclude $SBOX_ROOT/CPP/
#cfile ./CPP/Cycles.cpp ./CPP/isE2P.cpp

import os
from sage.all import ZZ
from sage.all import GF
from sage.all import matrix

from sage.libs.m4ri cimport *

from libcpp.map cimport map as mMap
from libcpp.vector cimport vector

from libc.stdlib cimport calloc,free

ctypedef vector[long long]* pV

cdef extern from "Cycles.h":
    mMap[long long, pV] findCycles(long long sbox[], long long s)

cdef extern from "isE2P.h":
    ctypedef struct pt:
        unsigned long long *start
        unsigned long long *end

    ctypedef struct E2P_parameters:
        unsigned long long *sbox
        unsigned long long length
        unsigned long long n
        vector[mzd_t*]     foundL
        pt                 progressTracker
        unsigned long long full
        unsigned long long ncpu
        unsigned long long cpu
        unsigned long long debug
        FILE               *output

    vector[mzd_t*] is_E2P(E2P_parameters io)

def cpp_cycles(pSbox,length):
    r"""
    Find chains and cycles in an array.

    It is a convenience function and connects cr_cycles() in CSbox with 
    findCycles() in Cycles.cpp
    
    INPUT::

        - ``pSbox`` -- array of integers
        - ``length`` -- length of array
        
    """
    cdef mMap[long long, pV] cycles
    cdef long long *cSbox = <long long *>calloc(length,sizeof(long long))

    for i in xrange(length):
        cSbox[i] = pSbox[i]

    cycles = findCycles(cSbox, length)

    free(cSbox)

    ret = []

    for i in xrange (1,cycles.size()+1):
        ret.append([])
        if not cycles[i].empty():
            for j in xrange (cycles[i].size()):
                ret[i-1].append(ZZ(cycles[i].at(j)))

    ret.sort(key=lambda c: len(c))

    return ret

def cpp_is_equivalent_to_permutation(**kwargs):
    r""" 
    Find matrix or matrices equivalent to a permutation.

    It is a convenience function and connects cr_is_equivalent_to_permutation_new() in CSbox with 
    isE2P() in isE2P.cpp

    INPUT::

        - ``pSbox``  -- array of integers
        - ``length`` -- length of array
        - ``n``      -- length of input bits
        - ``full``   -- if ``True`` return all matrices which give CCZ-equivalent permutations
    """
    # Read input parameters
    pSbox  = kwargs.get('sbox',None)
    length = kwargs.get('length',None)
    n      = kwargs.get('n',None)
    foundL = kwargs.get('foundL',None)
    pt     = kwargs.get('pt',None)
    full   = kwargs.get('full',None)
    ncpu   = kwargs.get('ncpu',None)
    cpu    = kwargs.get('cpu',None)
    debug  = kwargs.get('debug',None)

    if None in [pSbox,length,n,foundL,pt,full,ncpu,cpu,debug]:
        raise TypeError("Some of mandatory parameters are missed")

    # Define some variables 
    cdef E2P_parameters io

    io.sbox = <unsigned long long *>calloc(length,sizeof(unsigned long long))
    io.progressTracker.start = <unsigned long long *>calloc(n<<1,sizeof(unsigned long long))
    io.progressTracker.end = <unsigned long long *>calloc(n<<1,sizeof(unsigned long long))

    cdef vector[mzd_t*] cM

    # Convert Python S-box to C++ version
    for i in xrange(length):
        io.sbox[i] = pSbox[i]

    # Convert Python found L function from the list to C++ the matrix
    for l in xrange(len(foundL)):
        io.foundL.push_back(mzd_init(n, n<<1))
        for i in xrange(n):
            for j in xrange(n<<1):
                mzd_write_bit(io.foundL[l],i,j,(foundL[l][j]>>i) & 1)

    # Initialize progress tracker
    for i in xrange(n<<1):
        io.progressTracker.start[i] = pt[0][i]
        io.progressTracker.end[i]   = pt[1][i]

    # Initialize additional parameters
    io.length = length
    io.n = n
    io.full = full
    io.debug = debug
    io.ncpu = ncpu
    io.cpu = cpu

    # Find a linear matrix
    cM = is_E2P(io)

    # Delete unused parameters
    free(io.sbox)
    free(io.progressTracker.start)
    for i in xrange(io.foundL.size()):
        mzd_free(io.foundL[i])
    io.foundL.clear()

    # Extract all found matrices (if full is True)
    foundM = []
    M = matrix(GF(2),n<<1,n<<1)

    for m in xrange(cM.size()):
        for i in xrange(n<<1):
            for j in xrange(n<<1):
                M[i,j] = mzd_read_bit(cM[m],i,j)

        foundM.append(M)

        mzd_free(cM[m])

    # Delete vector of matrices (matrices themselves are deleted in the cycle)
    cM.clear()

    # Return different values based on input parameters
    if foundM == []:
        return []
    elif full is False:
        return foundM[0]
    else:
        return foundM
