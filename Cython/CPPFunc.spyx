r"""
    The interface for calling "cpp" functions

AUTHORS:

- Oleksandr Kazymyrov (2013-04-26): initial version

- Anna Maria Eilertsen, Oleksandr Kazymyrov (2013-08-14): updated description
"""

#*****************************************************************************
#       Copyright (C) 2013 Oleksandr Kazymyrov <oleksandr.kazymyrov@ii.uib.no>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************    

#clang c++
#cargs -Wall -Werror
#cinclude $SBOX_ROOT/CPP/
#cfile ./CPP/Cycles.cpp ./CPP/isE2P.cpp

import os
from sage.all import ZZ
from sage.all import GF
from sage.all import matrix

from sage.libs.m4ri cimport *

from libcpp.map cimport map as mMap
from libcpp.vector cimport vector

from libc.stdlib cimport malloc
from libc.stdlib cimport free

ctypedef vector[long long]* pV

cdef extern from "Cycles.h":
    mMap[long long, pV] findCycles(long long sbox[], long long s)

cdef extern from "isE2P.h":
    vector[mzd_t*] is_E2P(unsigned long long *sbox, unsigned long long length, unsigned long long n, unsigned long long full)

def cpp_cycles(pSbox,length):
    r"""
    Find chains and cycles in an array.

    It is a convenience function and connects cr_cycles() in CSbox with 
    findCycles() in Cycles.cpp
    
    INPUT::

        - ``pSbox`` -- array of integers
        - ``length`` -- length of array
        
    """
    cdef mMap[long long, pV] cycles
    cdef long long *cSbox = <long long *>malloc(length*sizeof(long long))

    for i in xrange(length):
        cSbox[i] = pSbox[i]

    cycles = findCycles(cSbox, length)

    free(cSbox)

    ret = []

    for i in xrange (1,cycles.size()+1):
        ret.append([])
        if not cycles[i].empty():
            for j in xrange (cycles[i].size()):
                ret[i-1].append(ZZ(cycles[i].at(j)))

    ret.sort(key=lambda c: len(c))

    return ret

def cpp_is_equivalent_to_permutation(pSbox,length,n,full=False):
    r""" 
    Find matrix or matrices equivalent to a permutation.

    It is a convenience function and connects cr_is_equivalent_to_permutation_new() in CSbox with 
    isE2P() in isE2P.cpp

    INPUT::

        - ``pSbox``  -- array of integers
        - ``length`` -- length of array
        - ``n``      -- length of input bits
        - ``full``   -- if ``True`` return all matrices which give CCZ-equivalent permutations
    """
    cdef unsigned long long *cSbox = <unsigned long long *>malloc(length*sizeof(long long))
    cdef vector[mzd_t*] cM

    for i in xrange(length):
        cSbox[i] = pSbox[i]

    cM = is_E2P(cSbox, length, n, full)

    free(cSbox)
    foundM = []
    M = matrix(GF(2),n<<1,n<<1)

    for m in xrange(cM.size()):
        for i in xrange(n<<1):
            for j in xrange(n<<1):
                M[i,j] = mzd_read_bit(cM[m],i,j)

        foundM.append(M)

        mzd_free(cM[m])

    cM.clear()

    if full is False:
        return foundM[0]
    else:
        return foundM
